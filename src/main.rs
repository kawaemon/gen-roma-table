use {
    anyhow::{Context as _, Result},
    lazy_static::lazy_static,
    scraper::{Html, Selector},
};

fn main() -> Result<()> {
    let html = reqwest::blocking::get("http://www.hachinohe.ed.jp/hens/ad/keyboard/keyboard05.htm")
        .and_then(|x| x.text_with_charset("shift_jis"))
        .context("failed to fetch roma table")?;

    // auto-generated by browser dev tool
    const FIRST_TBODY_TR_SELECTOR: &str = "body > table:nth-child(2) > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(1) > table:nth-child(1) > tbody:nth-child(1) > tr";
    const SECOND_TBODY_TR_SELECTOR: &str = "body > table:nth-child(2) > tbody:nth-child(1) > tr:nth-child(1) > td:nth-child(2) > table:nth-child(1) > tbody:nth-child(1) > tr";

    let first_tbody_tr_selector = Selector::parse(FIRST_TBODY_TR_SELECTOR).unwrap();
    let second_tbody_tr_selector = Selector::parse(SECOND_TBODY_TR_SELECTOR).unwrap();
    let html = Html::parse_document(&html);

    let singles = extract(&html, &first_tbody_tr_selector);
    let doubles = extract(&html, &second_tbody_tr_selector);

    println!("{}", MyCLanguageFormatter::format(&singles, &doubles));

    Ok(())
}

#[derive(Debug)]
struct RomaPair<'a> {
    hiragana: &'a str,
    romas: [Option<&'a str>; 2],
}

fn extract<'tree>(tree: &'tree Html, table_tr_selector: &Selector) -> Vec<RomaPair<'tree>> {
    // table width is 5
    let mut buffer: [&str; 5] = [""; 5];
    let mut result = vec![];
    let mut is_kana = true;

    for tr in tree.select(table_tr_selector) {
        lazy_static! {
            static ref TEXT_SELECTOR: Selector = Selector::parse("td > font").unwrap();
        }

        if is_kana {
            for (index, text) in tr.select(&TEXT_SELECTOR).enumerate() {
                buffer[index] = text.text().next().unwrap();
            }

            is_kana = false;
        } else {
            for (index, text) in tr.select(&TEXT_SELECTOR).enumerate() {
                let hiragana = buffer[index];
                let roma = text.text().next().unwrap();

                if hiragana.trim().is_empty() || roma.trim().is_empty() {
                    continue;
                }

                let mut roma_array = [None; 2];
                for (index, roma) in roma.split(',').enumerate() {
                    roma_array[index] = Some(roma.trim());
                }

                result.push(RomaPair {
                    hiragana,
                    romas: roma_array,
                })
            }

            is_kana = true;
        }
    }

    result
}

trait Formatter {
    fn format(singles: &[RomaPair<'_>], doubles: &[RomaPair<'_>]) -> String;
}

struct MyCLanguageFormatter;
impl Formatter for MyCLanguageFormatter {
    fn format(singles: &[RomaPair<'_>], doubles: &[RomaPair<'_>]) -> String {
        let body = singles
            .iter()
            .map(|pair| {
                #[rustfmt::skip]
                let (mut romas, romas_len) = pair
                    .romas
                    .iter()
                    .flat_map(|x| x.iter())
                    .fold((String::new(), 0),
                        |(mut a, count), b| {
                            a += "\"";
                            a += &b.to_ascii_lowercase();
                            a += "\", ";
                            (a, count + 1)
                        },
                    );

                assert!(romas_len != 0);

                romas.pop();
                romas.pop();

                format!(
                    "__GET_ROMA_IMPL(\"{}\", {}, {})",
                    pair.hiragana, romas_len, romas
                )
            })
            .collect::<Vec<_>>()
            .join("\n    ");

        #[rustfmt::skip]
        let result = format!(
"struct Slice {{
    const size_t length;
    const char **pointer;
}};

#define __GET_ROMA_IMPL(HIRAGANA, ROMAS_LEN, ...) \
    if (string_eq(hiragana, HIRAGANA)) {{ \
        const static char *romas[] = {{__VA_ARGS__}}; \
        const static struct Slice data = {{ROMAS_LEN, romas}}; \
        return &data; \
    }}

const struct Slice *get_roma(const char *hiragana) {{
    {}

    return NULL;
}}
",
            body
        );

        result
    }
}
